---
layout:     post
title:      Hbase协处理器
subtitle:   Hbase协处理器
date:       2018-10-31
author:     XINGXING
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Hbase
---

>
>Hbase协处理器篇
> 


### Coprocessor简介
HBase协处理器的灵感来自于Jeff Dean 09年的演讲，根据该演讲实现类似于Bigtable的协处理器，包括以下特性:**每个表服务器的任意子表都可以运行代码客户端的高层调用接口**(客户端能够直接访问数据表的行地址，多行读写会自动分片成多个并行的RPC调用)，提供一个非常灵活的、可用于建立分布式服务的数据模型，能够自动化扩展、负载均衡、应用请求路由。HBase的协处理器灵感来自Bigtable，但是实现细节不尽相同。HBase建立框架为用户提供类库和运行时环境，使得代码能够在HBase Region Server和Master上面进行处理。
![](https://ws1.sinaimg.cn/large/006tNbRwly1fwrf6muk01j318o0p4th7.jpg)

***实现目的***  

1.HBase无法轻易建立“二级索引”；  
2.执行求和、计数、排序等操作比较困难，必须通过MapReduce/Spark实现，对于简单的统计或聚合计算时，可能会因为网络与IO开销大而带来性能问题。  

**灵感来源**  

1.灵感来源于Bigtable的协处理器，包含如下特性：  
2.每个表服务器的任意子表都可以运行代码；  
3.客户端能够直接访问数据表的行，多行读写会自动分片成多个并行的RPC调用。  

**提供接口**  

1.RegionObserver：提供客户端的数据操纵事件钩子：Get、Put、Delete、Scan等；  
2.WALObserver：提供WAL相关操作钩子；  
3.MasterObserver：提供DDL-类型的操作钩子。如创建、删除、修改数据表等；  
4.Endpoint：终端是动态RPC插件的接口，它的实现代码被安装在服务器端，能够通过HBase RPC调用唤醒。  

**应用范围**  

1.通过使用RegionObserver接口可以实现二级索引的创建和维护；  
2.通过使用Endpoint接口，在对数据进行简单排序和sum，count等统计操作时，能够极大提高性能。  

### Endpoint服务端实现

在传统关系型数据库里面，可以随时的对某列进行求和sum，但是目前HBase目前所提供的接口，直接求和是比较困难的，所以先编写好服务端代码，并加载到对应的Table上，加载协处理器有几种方法，可以通过HTableDescriptor的addCoprocessor方法直接加载，同理也可以通过removeCoprocessor方法卸载协处理器。  
Endpoint协处理器类似传统数据库的存储过程，**客户端调用Endpoint协处理器执行一段Server端代码，并将Server端代码的结果返回给Client进一步处理**，最常见的用法就是进行聚合操作。举个例子说明：如果没有协处理器，当用户需要找出一张表中的最大数据即max聚合操作，必须进行全表扫描，客户端代码遍历扫描结果并执行求max操作，这样的方法无法利用底层集群的并发能力，而将所有计算都集中到Client端统一执行， 效率非常低。但是使用Coprocessor，用户将求max的代码部署到HBase Server端，HBase将利用底层Cluster的多个节点并行执行求max的操作即在每个Region范围内执行求最大值逻辑，将每个Region的最大值在Region Server端计算出，仅仅将该max值返回给客户端。客户端进一步将多个Region的max进一步处理而找到其中的max，这样整体执行效率提高很多。但是一定要注意的是Coprocessor一定要写正确，否则导致RegionServer宕机。
![](https://ws4.sinaimg.cn/large/006tNbRwly1fwrfhuat4kj31940p6jvq.jpg)

**Protobuf定义**

如前所述，客户端和服务端之间需要进行RPC通信，所以两者间需要确定接口，当前版本的HBase的协处理器是通过Google Protobuf协议来实现数据交换的，所以需要通过Protobuf来定义接口。  
如下所示：
```java
option java_package = "com.my.hbase.protobuf.generated";
option java_outer_classname = "AggregateProtos";
option java_generic_services = true;
option java_generate_equals_and_hash = true;
option optimize_for = SPEED;

import "Client.proto";

message AggregateRequest {
    required string interpreter_class_name = 1;
    required Scan scan = 2;
    optional bytes  interpreter_specific_bytes = 3;
}

message AggregateResponse {
    repeated bytes first_part = 1;
    optional bytes second_part = 2;
}

service AggregateService {
    rpc GetMax (AggregateRequest) returns (AggregateResponse);
    rpc GetMin (AggregateRequest) returns (AggregateResponse);
    rpc GetSum (AggregateRequest) returns (AggregateResponse);
    rpc GetRowNum (AggregateRequest) returns (AggregateResponse);
    rpc GetAvg (AggregateRequest) returns (AggregateResponse);
    rpc GetStd (AggregateRequest) returns (AggregateResponse);
    rpc GetMedian (AggregateRequest) returns (AggregateResponse);
}
```
可以看到这里定义7个聚合服务RPC，名字分别叫做GetMax、GetMin、GetSum等，本文通过GetSum进行举例，其他的聚合RPC也是类似的内部实现。RPC有一个入口参数，用消息AggregateRequest表示；RPC的返回值用消息AggregateResponse表示。Service是一个抽象概念，RPC的Server端可以看作一个用来提供服务的Service。  
在HBase Coprocessor中Service就是Server端需要提供的Endpoint Coprocessor服务，主要用来给HBase的Client提供服务。
AggregateService.java是由Protobuf软件通过终端命令“protoc filename.proto--java_out=OUT_DIR”自动生成的，其作用是将.proto文件定义的消息结构以及服务转换成对应接口的RPC实现，其中包括如何构建request消息和response响应以及消息包含的内容的处理方式，并且将AggregateService包装成一个抽象类，具体的服务以类的方法的形式提供。  
AggregateService.java定义Client端与Server端通信的协议，代码中包含请求信息结构AggregateRequest、响应信息结构AggregateResponse、提供的服务种类AggregateService，其中AggregateRequest中的interpreter_class_name指的是column interpreter的类名，此类的作用在于将数据格式从存储类型解析成所需类型。AggregateService.java由于代码太长，在这里就不贴出来了。
