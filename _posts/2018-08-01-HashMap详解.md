---
layout:     post
title:      HashMap详解
subtitle:   HashMap详解
date:       2018-08-01
author:     XINGXING
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Java
---

>
>HashMap详解篇
> 


先看下Map的类结构，可以看到TreeMap是基于树实现的，HashMap，HashTable，ConcurrentHashMap是基于Hash来实现的，而HashTable和HashMap的底层实现基本一致，只不过是HashTable通过synchronized关键字修饰实现了线程安全性，是一个同步容器，而ConcurrentHashMap是一个并发容器，再多线程并发的场景下性能要比HashTable好很多；
![](https://ws3.sinaimg.cn/large/006tNbRwly1fxpwtx1gxlj311w0komxn.jpg)


HashMap其实就是key-value结构，如下代码：
```java
    Map map=new HashMap<String,String>();
    map.put("1", "one");
    map.put("2", "two");
    map.put("3", "three");
    map.put("4", "four");
    map.put("5", "five");
    map.put("6", "six");
```

我们再来看下HashMap的源码，来看几个重要的要素:
```java

    /**
     * HashMap底层是使用数组来存储数据节点的，此table变量就是HashMap用于存储的数组
     * The table, initialized on first use, and resized as
     * necessary. When allocated, length is always a power of two.
     * (We also tolerate length zero in some operations to allow
     * bootstrapping mechanics that are currently not needed.)
     */
    transient Node<K,V>[] table;
    
    /**
     * HashMap的逻辑长度
     * The number of key-value mappings contained in this map.
     */
    transient int size;
    
    /**
     * HashMap的修改次数
     */
    transient int modCount;

    /**
     * 默认的负载因子，当HashMap的剩余容量<总容量*DEFAULT_LOAD_FACTOR时,就触发扩容
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    
    
    /**
     * 用于存储的数据节点
     * Basic hash bin node, used for most entries.  (See below for
     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
     */
    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash; //每个key的hash值
        final K key;    //用于存储的key
        V value;        //用于存储的value
        Node<K,V> next; //用于指向下一个节点的内存地址
        
        //Node的构造函数
        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }
        
        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
    
    
    /**
     * HashMap的构造函数一，使用默认的初始化容量16，和默认的负载因子0.75
     * Constructs an empty <tt>HashMap</tt> with the default initial capacity
     * (16) and the default load factor (0.75).
     */
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
    
    /**
     * HashMap的构造函数二，指定初始化容量          
     * Constructs an empty <tt>HashMap</tt> with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param  initialCapacity the initial capacity.
     * @throws IllegalArgumentException if the initial capacity is negative.
     */
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    
    /**
     * HashMap的构造函数三，指定初始化容量和负载因子    
     * Constructs an empty <tt>HashMap</tt> with the specified initial
     * capacity and load factor.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }


```

