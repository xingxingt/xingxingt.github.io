---
layout:     post
title:      Java代理和动态代理
subtitle:   Java代理和动态代理
date:       2018-11-14
author:     XINGXING
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Nginx
---

>
>Java代理和动态代理篇
> 

**创建代理接口**  
在Java中，代理对象往往实现和目标对象一直的接口，并作为目标对象的代替，接受来自其他的调用，并将全部或者部分调用转发给目标对象，在这过程中**实现代理接口和调用转发**是代理对象必须要完成的重要任务;  
在完成上述两个任务的同时，代理对象可以在调用转发前和转发后执行一些功能，例如日志输出，访问控制，或者是一些复杂的附加逻辑，像spring的AOP的实现；而这些附加逻辑正是体现代理对象的重要价值;   
如下代理序列图:  
![](https://ws3.sinaimg.cn/large/006tNbRwly1fx7pyvwjd6j30z40uiq4w.jpg)  

`java.lang.reflect.Proxy`提供了用于创建代理类和对象的静态方法，也就是说通过`java.lang.reflect.Proxy`可以动态的创建某个接口实现代理对象；代理对象的另一个重要重要的任务是调用转发，一般由`java.lang.reflect.InvocationHandler`该接口的实例来完成,接口实例负责处理接口上的方法调用并返回结果;
Proxy比较重要的方法如下: 
```java
public class Proxy implements java.io.Serializable {

    private static final long serialVersionUID = -2222568056686623797L;
    
    //用于获取代理类的class对象，该代理类将定义在指定的类加载器中，并将实现参数interfaces的所有接口，该类只创建一次
    @CallerSensitive
    public static Class<?> getProxyClass(ClassLoader loader,
                                         Class<?>... interfaces)
        throws IllegalArgumentException
    {
       ........
    }
    
    //创建代理对象
    @CallerSensitive
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
         ........
    }
    
    //判断class对象是否是代理类        
    public static boolean isProxyClass(Class<?> cl) {
        return Proxy.class.isAssignableFrom(cl) && proxyClassCache.containsValue(cl);
    }

    //获取代理实例对应的调用处理程序           
    @CallerSensitive
    public static InvocationHandler getInvocationHandler(Object proxy)
        throws IllegalArgumentException
    {
        ........
    }
    
}    
```

**调用转发**
创建接口实现由`java.lang.reflect.Proxy`而调用转发由`java.lang.reflect.InvocationHandler`的实例来完成，

