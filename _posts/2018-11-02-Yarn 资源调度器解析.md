---
layout:     post
title:      Yarn 资源调度器解析
subtitle:   Yarn 资源调度器解析
date:       2018-10-31
author:     XINGXING
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Yarn
---

>
>Yarn 资源调度器解析篇
> 


### Yarn资源调度器简介
资源调度器是Yarn中最核心的组件之一，他是ResourceManager中的一个可插拔的服务组件，负责整个集群的管理和分配;  
目前Yarn中的作业类型:    
1.批处理作业,这种作业比较耗时，对时间的完成没有严格要求，如数据挖掘和机器学习等;  
2.交互式作业，这种作业一半希望能够及时的返回结果，例如：hive的sql查询;  
3.生产性作业:这种作业要求有一定量的资源保证，如统计值计算,垃圾数据分析等;  

为了满足多用户多队列的资源分配问题以及Yarn自带的FIFO(先进先出资源调度器)单队列的问题，又引入了Yahoo的Capacity Scheduler和FaceBook的Fair Scheduler；

### Yarn的资源调度器的基本架构 
资源调度器作为Yarn中的可插拔的资源调度器,它定义了一套接口规范以便用户可按照规范实现自己的调度器，本文主要从资源调度器的可插拔性和时间处理器两方面来说;

**1.ResourceScheduler之插拔式组件**  
在ResourceManager初始化的时候会根据用户的配置来创建一个具体的资源调度对象,通过配置文件yarn.resourcemanager.scheduler.class指定,如下代码:
```java
  protected ResourceScheduler createScheduler() {
    String schedulerClassName = conf.get(YarnConfiguration.RM_SCHEDULER,
        YarnConfiguration.DEFAULT_RM_SCHEDULER);
    LOG.info("Using Scheduler: " + schedulerClassName);
    try {
      Class<?> schedulerClazz = Class.forName(schedulerClassName);
      if (ResourceScheduler.class.isAssignableFrom(schedulerClazz)) {
        return (ResourceScheduler) ReflectionUtils.newInstance(schedulerClazz,
            this.conf);
      } else {
        throw new YarnRuntimeException("Class: " + schedulerClassName
            + " not instance of " + ResourceScheduler.class.getCanonicalName());
      }
    } catch (ClassNotFoundException e) {
      throw new YarnRuntimeException("Could not instantiate Scheduler: "
          + schedulerClassName, e);
    }
  }
```
资源调度器的实现必须实现ResourceScheduler接口,代码如下:
```java
@LimitedPrivate("yarn")
@Evolving
public interface ResourceScheduler extends YarnScheduler, Recoverable {

  /**
   * Set RMContext for <code>ResourceScheduler</code>.
   * This method should be called immediately after instantiating
   * a scheduler once.
   * @param rmContext created by ResourceManager
   */
  void setRMContext(RMContext rmContext);

  /**
   * Re-initialize the <code>ResourceScheduler</code>.
   * @param conf configuration
   * @throws IOException
   */
  void reinitialize(Configuration conf, RMContext rmContext) throws IOException;
}
```
而ResourceScheduler实现了YarnScheduler接口，代码如下:
```java
public interface YarnScheduler extends EventHandler<SchedulerEvent> {

  /**
   * Get queue information
   * @param queueName queue name
   * @param includeChildQueues include child queues?
   * @param recursive get children queues?
   * @return queue information
   * @throws IOException
   */
  //todo 获取一个队列信息
  @Public
  @Stable
  public QueueInfo getQueueInfo(String queueName, boolean includeChildQueues,
      boolean recursive) throws IOException;

  /**
   * Get acls for queues for current user.
   * @return acls for queues for current user
   */
  //todo 返回当前用户的队列Acl权限
  @Public
  @Stable
  public List<QueueUserACLInfo> getQueueUserAclInfo();
  
  .......
```
**2.ResourceScheduler之事件处理器**  
Yarn的资源管理器实际上是一个事件处理器，他需要处理来自外部不同的事件,如下图所示：  
![](https://ws2.sinaimg.cn/large/006tNbRwly1fwx0jhkdefj31kw0otdik.jpg)

**3.资源表示模型**  
当前Yarn支持内存和CPU两种资源类型的管理和分配，同MR1一样，Yarn采用了动态资源分配机制，NM会向RM注册，注册信息里包含了该节点可分配的CPU和内存总量;
这两个值是可以配置的：
    
    yarn.nodemanager.resource.memory-mb	: 可分配的物理内存总量,默认8G;
    yarn.nodemanager.vmem-pmem-ratio	: 使用单位物理内存可分配的虚拟内存量，默认2.1；
    yarn.nodemanager.resource.cpu-vcores: 可分配虚拟CPU的个数,默认是8;
    
Yarn支持的调度语义：  
1. 请求某个特定节点上的特定资源量: 例如请求nodex节点上5个 2vcpu,2GB的Container;
2. 请求某个特定机架上的特定资源量: 例如请求rackx上的3个  4vcpu,2GB的Container;
3. 将某些节点加入或者移除黑名单，不再为自己分配这些节点上的资源;
4. 请求归还某些资源,例如ApplicationMaster将闲置的Container归还给集群;

不支持的调度语义：  
1. 请求任意节点上的特定资源量: 例如请求任意节点上5个 2vcpu,2GB的Container;
2. 请求任意机架上的特定资源量: 例如请求同一机架上的3个  4vcpu,2GB的Container;
3. 请求一组或者几组符合某种特质的资源，例如请求两个机架上的4个2vcpu,2GB的Container和4vcpu,2GB的Container,如果集群中没有则需要从其他应用程序抢占资源;
4. 超细粒度的资源: 例如CPU性能要求，绑定CPU；
5. 动态调整Container资源，应允许根据需要冬天调整Container资源量;









