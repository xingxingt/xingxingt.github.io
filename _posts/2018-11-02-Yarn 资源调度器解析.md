---
layout:     post
title:      Yarn 资源调度器解析
subtitle:   Yarn 资源调度器解析
date:       2018-10-31
author:     XINGXING
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Yarn
---

>
>Yarn 资源调度器解析篇
> 


### Yarn资源调度器简介
资源调度器是Yarn中最核心的组件之一，他是ResourceManager中的一个可插拔的服务组件，负责整个集群的管理和分配;  
目前Yarn中的作业类型:    
1.批处理作业,这种作业比较耗时，对时间的完成没有严格要求，如数据挖掘和机器学习等;  
2.交互式作业，这种作业一半希望能够及时的返回结果，例如：hive的sql查询;  
3.生产性作业:这种作业要求有一定量的资源保证，如统计值计算,垃圾数据分析等;  

为了满足多用户多队列的资源分配问题以及Yarn自带的FIFO(先进先出资源调度器)单队列的问题，又引入了Yahoo的Capacity Scheduler和FaceBook的Fair Scheduler；

### Yarn的资源调度器的基本架构 
资源调度器作为Yarn中的可插拔的资源调度器,它定义了一套接口规范以便用户可按照规范实现自己的调度器，本文主要从资源调度器的可插拔性和时间处理器两方面来说;

**1.ResourceScheduler之插拔式组件**  
在ResourceManager初始化的时候会根据用户的配置来创建一个具体的资源调度对象,通过配置文件yarn.resourcemanager.scheduler.class指定,如下代码:
```java
  protected ResourceScheduler createScheduler() {
    String schedulerClassName = conf.get(YarnConfiguration.RM_SCHEDULER,
        YarnConfiguration.DEFAULT_RM_SCHEDULER);
    LOG.info("Using Scheduler: " + schedulerClassName);
    try {
      Class<?> schedulerClazz = Class.forName(schedulerClassName);
      if (ResourceScheduler.class.isAssignableFrom(schedulerClazz)) {
        return (ResourceScheduler) ReflectionUtils.newInstance(schedulerClazz,
            this.conf);
      } else {
        throw new YarnRuntimeException("Class: " + schedulerClassName
            + " not instance of " + ResourceScheduler.class.getCanonicalName());
      }
    } catch (ClassNotFoundException e) {
      throw new YarnRuntimeException("Could not instantiate Scheduler: "
          + schedulerClassName, e);
    }
  }
```
资源调度器的实现必须实现ResourceScheduler接口,代码如下:
```java
@LimitedPrivate("yarn")
@Evolving
public interface ResourceScheduler extends YarnScheduler, Recoverable {

  /**
   * Set RMContext for <code>ResourceScheduler</code>.
   * This method should be called immediately after instantiating
   * a scheduler once.
   * @param rmContext created by ResourceManager
   */
  void setRMContext(RMContext rmContext);

  /**
   * Re-initialize the <code>ResourceScheduler</code>.
   * @param conf configuration
   * @throws IOException
   */
  void reinitialize(Configuration conf, RMContext rmContext) throws IOException;
}
```
而ResourceScheduler实现了YarnScheduler接口，代码如下:
```java
public interface YarnScheduler extends EventHandler<SchedulerEvent> {

  /**
   * Get queue information
   * @param queueName queue name
   * @param includeChildQueues include child queues?
   * @param recursive get children queues?
   * @return queue information
   * @throws IOException
   */
  //todo 获取一个队列信息
  @Public
  @Stable
  public QueueInfo getQueueInfo(String queueName, boolean includeChildQueues,
      boolean recursive) throws IOException;

  /**
   * Get acls for queues for current user.
   * @return acls for queues for current user
   */
  //todo 返回当前用户的队列Acl权限
  @Public
  @Stable
  public List<QueueUserACLInfo> getQueueUserAclInfo();
  
  .......
```
**2.ResourceScheduler之事件处理器**  
Yarn的资源管理器实际上是一个事件处理器，他需要处理来自外部不同的事件,如下图所示：  

![](https://ws3.sinaimg.cn/large/006tNbRwly1fwx8qx4slsj31kw0peju3.jpg)


### 资源表示模型
当前Yarn支持内存和CPU两种资源类型的管理和分配，同MR1一样，Yarn采用了动态资源分配机制，NM会向RM注册，注册信息里包含了该节点可分配的CPU和内存总量;
这两个值是可以配置的：
    
    yarn.nodemanager.resource.memory-mb	: 可分配的物理内存总量,默认8G;
    yarn.nodemanager.vmem-pmem-ratio	: 使用单位物理内存可分配的虚拟内存量，默认2.1；
    yarn.nodemanager.resource.cpu-vcores: 可分配虚拟CPU的个数,默认是8;
    
Yarn支持的调度语义：  
1. 请求某个特定节点上的特定资源量: 例如请求nodex节点上5个 2vcpu,2GB的Container;
2. 请求某个特定机架上的特定资源量: 例如请求rackx上的3个  4vcpu,2GB的Container;
3. 将某些节点加入或者移除黑名单，不再为自己分配这些节点上的资源;
4. 请求归还某些资源,例如ApplicationMaster将闲置的Container归还给集群;

不支持的调度语义：  
1. 请求任意节点上的特定资源量: 例如请求任意节点上5个 2vcpu,2GB的Container;
2. 请求任意机架上的特定资源量: 例如请求同一机架上的3个  4vcpu,2GB的Container;
3. 请求一组或者几组符合某种特质的资源，例如请求两个机架上的4个2vcpu,2GB的Container和4vcpu,2GB的Container,如果集群中没有则需要从其他应用程序抢占资源;
4. 超细粒度的资源: 例如CPU性能要求，绑定CPU；
5. 动态调整Container资源，应允许根据需要冬天调整Container资源量;


### 资源调度模型 
**1.双层资源调度模型**  
在第一层中，ResourceManager中的资源调度器将资源分配给各个ApplicationMaster;  
在第二层中，ApplicationMaster再进一步将资源分配给它内部的各个任务  
第一层的调度模型如下图所示：  

![](https://ws2.sinaimg.cn/large/006tNbRwly1fwx873vybuj31kw0nq0u3.jpg)

**2.资源保证机制**
在分布式计算中，资源调度器需要选择合适峰资源保证这样的机制,当应用程序申请的资源暂时无法保证时:  
1.是优先为应用程序预留一个节点上的资源直到累计释放的空闲资源满足应用程序需求（称为“增量资源分配”）  
2.还是暂时放弃当前资源直到出现一个节点剩余资源一次性满足应用程序需求（称为“一次性资源分配”）  
这两种机制均存在优缺点，对于增量资源分配来说，资源预留会导致资源浪费，降低集群资源利用率；而一次性资源分配则会产生饿死现象，即应用程序可能永远等不到满足资源需求的节点出现,YARN采用了增量资源分配机制 ，尽管这种机制会造成浪费，但不会出现饿死现象;


**3.资源分配算法**  
为了支持多维资源调度，YARN资源调度器采用了主资源公平调度算法（DRF），该算法扩展了最大最小公平算法，使其能够支持多维资源的使用在DRF算法中，将所需份额（资源比例）最大的资源称为主资源，而DRF的基本设计思想则是将最大最小公平算法应用于主资源上，进而将多维资源调度问题转化为单资源调度问题，即DRF总是最大化所有主资源中最小的;


### 资源抢占模型 



### Capacity Scheduler
Capacity Scheduler是Yahoo开发的多用户调度器，它以队列为单位，每个队列可设定一定比例的资源最低保证和使用上限，同时每个用户也可以设定一定的资源使用上限以防止资源滥用。当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列;
Capacity Scheduler特点:  
1. 容量保证:管理员可以为每个队列设置资源的最低保证和使用上限，而所有提交到该队列的应用程序共享这些资源;
2. 灵活性: 当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列,一旦该队列有闲的应用程序提交，则其他队列释放的资源会归还该队列;
3. 多重租赁: 支持多用户共享集群和多应用程序同时运行;
4. 安全性保证: 每个队列都有严格的ACL列表规定他的访问用户;
5. 动态更新配置文件: 管理员可根据需要动态修改各种配置参数，以实现集群的在线管理;









